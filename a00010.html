<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>avr.sdk: Référence du fichier include/RFID/MFRC522.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">avr.sdk
   </div>
   <div id="projectbrief">SDK pour les projets AVR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&#160;associées</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Structures&#160;de&#160;données</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Liste&#160;des&#160;fichiers</span></a></li>
      <li><a href="globals.html"><span>Variables&#160;globale</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00010.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Structures de données</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Énumérations</a> &#124;
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier MFRC522.h<div class="ingroups"><a class="el" href="a00017.html">RFID</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Bibliothèque de contrôle du lecteur MFRC522.  
<a href="#details">Plus de détails...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="a00011_source.html">RFID/MFRC522_core.h</a>&gt;</code><br />
</div>
<p><a href="a00010_source.html">Aller au code source de ce fichier.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Structures de données</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">MFRC522_PICC_UID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure contenant l'UID d'un PICC.  <a href="a00002.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html">MFRC522_MIFARE_KEY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure d'une clef Crypto1 MIFARE.  <a href="a00001.html#details">Plus de détails...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae08583699989a52ba709c10416da4049"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ae08583699989a52ba709c10416da4049">MFRC522_AUTH_KEY_SIZE</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ae08583699989a52ba709c10416da4049"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Énumérations</h2></td></tr>
<tr class="memitem:a8ed729867f3e31ba760da8cdf874c9d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> { <br />
&#160;&#160;<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7aed60c850eb757e8c9bb408da0b9f2460">MFRC522_STATUS_OK</a> = 1, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7afb2bf8b2b3b762f8881f4b50becffbe7">MFRC522_STATUS_ERROR</a> = 2, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a66c6e7b431d9c23df53dde3b31c44ab5">MFRC522_STATUS_COLLISION</a> = 3, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a75dc0fdffad4fc369637e38d39378386">MFRC522_STATUS_TIMEOUT</a> = 4, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7afd52fd20b34b011fbec8d5062a0f87e1">MFRC522_STATUS_NO_ROOM</a> = 5, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a9cfb9908f0583d4cfb7b789511c61e67">MFRC522_STATUS_INTERNAL_ERROR</a> = 6, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a3bf363bbf4ddb7134662d1ad48c7934f">MFRC522_STATUS_INVALID</a> = 7, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a1614845f5f84e683c97e84aed6dfd255">MFRC522_STATUS_CRC_WRONG</a> = 8, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a627fb17aba855e860a82e8b7300f7e94">MFRC522_STATUS_MIFARE_NACK</a> = 9, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a34fca9ae70a2078ae9aa791acb68f5b6">MFRC522_STATUS_PROPRIETARY_ANTICOLLISION</a> = 10, 
<a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7a8b7b2abc49823383fc4ac7cf89709007">MFRC522_STATUS_BCC_ERROR</a> = 11
<br />
 }<tr class="memdesc:a8ed729867f3e31ba760da8cdf874c9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codes retour des fonctions de la bibliothèque.  <a href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8ed729867f3e31ba760da8cdf874c9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a8747255baf96533a382042038f5d01e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2">MFRC522_RX_GAIN</a> { <br />
&#160;&#160;<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2afcb05273c274750cba2cb1ae8ec31d46">MFRC522_RX_GAIN_18dB</a> = 0x00, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a9ab1cf9c2403c2949445703731c3cf00">MFRC522_RX_GAIN_23dB</a> = 0x01, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a74acf107731fe1219418952ce2305d0b">MFRC522_RX_GAIN_18dB_2</a> = 0x02, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2abad30223c4834bf710e92114c744e4b4">MFRC522_RX_GAIN_23dB_2</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2aa6fcbb3cd63e11fca940078f9e8dbf4e">MFRC522_RX_GAIN_33dB</a> = 0x04, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a8a38c126caee6ca9fb7e367c1bc71e56">MFRC522_RX_GAIN_38dB</a> = 0x05, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a084739aeeced2f9026282737599ccdc6">MFRC522_RX_GAIN_43dB</a> = 0x06, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a63303a08e7efc9260a3941c66724204e">MFRC522_RX_GAIN_48dB</a> = 0x07, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a5f11b0cec323f27214e932956a947b10">MFRC522_RX_GAIN_min</a> = 0x00, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2aa7596c72c96bc7fa61de6656348bddf1">MFRC522_RX_GAIN_avg</a> = 0x04, 
<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2a47711a5991c0a3c7d8519bfbb5f4fc9e">MFRC522_RX_GAIN_max</a> = 0x07
<br />
 }<tr class="memdesc:a8747255baf96533a382042038f5d01e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gain de l'antenne du MFRC522.  <a href="a00010.html#a8747255baf96533a382042038f5d01e2">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8747255baf96533a382042038f5d01e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a1ab910a4592d91fed8ceb9c8f2014c6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6e">MFRC522_PICC_TYPE</a> { <br />
&#160;&#160;<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea9c158029c33cf5f4af7e5500d4a1adc3">MFRC522_PICC_TYPE_UNKNOWN</a> = 0, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea54181fb39067b717ec991e8b7cee9b8c">MFRC522_PICC_TYPE_ISO_14443_4</a> = 1, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6eab17aa2fc84ed855b8f0739913068e5ad">MFRC522_PICC_TYPE_ISO_18092</a> = 2, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea82440ae14051cfd6a163c44a368ceb37">MFRC522_PICC_TYPE_MIFARE_MINI</a> = 3, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6eaa0842ffe78c7eb0e3e50023ab8555206">MFRC522_PICC_TYPE_MIFARE_1K</a> = 4, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea66d516f2f32de4afb43216b5ccf86804">MFRC522_PICC_TYPE_MIFARE_4K</a> = 5, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea5bdab066171aabf26e4a51a6b6f82abc">MFRC522_PICC_TYPE_MIFARE_UL</a> = 6, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea7c1ca3a1d6007e3d8756683fbe9a2f29">MFRC522_PICC_TYPE_MIFARE_PLUS</a> = 7, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea83f7ce6e4e57aacd2202e4f46cafb5d7">MFRC522_PICC_TYPE_TNP3XXX</a> = 8, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea7e9a94106c447f4bf2961d0c5fe5557b">MFRC522_PICC_TYPE_MIFARE_DESFIRE</a> = 9, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea6b65c8717db71b024d2a7a123b32a74f">MFRC522_PICC_TYPE_JCOP30</a> = 10, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6eaf9380812869951aa2e681c405eb0c754">MFRC522_PICC_TYPE_MIFARE_4K_EMUL</a> = 11, 
<br />
&#160;&#160;<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6ea9e0213161362742f92643edce79d1e0a">MFRC522_PICC_TYPE_MIFARE_1K_INFINEON</a> = 12, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6eacda3341fc8f2e14b82d48fe3557e6859">MFRC522_PICC_TYPE_MPCOS</a> = 13, 
<a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6eada76c526ba87176f4f628d82dc4434cb">MFRC522_PICC_TYPE_NOT_COMPLETE</a> = 255
<br />
 }<tr class="memdesc:a1ab910a4592d91fed8ceb9c8f2014c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types de PICC ou de TAG.  <a href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1ab910a4592d91fed8ceb9c8f2014c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a89adaf1e8ac46b6d0c7bb83c58d152d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4">MFRC522_AUTH_KEY</a> { <a class="el" href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4a1050aafc23ebab8d7c32a82fdfdaf954">MFRC522_AUTH_KEY_A</a> = 0, 
<a class="el" href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4af338d6034d98313cb5f2b2ce58f8e8cd">MFRC522_AUTH_KEY_B</a> = 1
 }<tr class="memdesc:a89adaf1e8ac46b6d0c7bb83c58d152d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types d'authentifications.  <a href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a89adaf1e8ac46b6d0c7bb83c58d152d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:a88a7a1256442e386634da01b9b874998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a88a7a1256442e386634da01b9b874998">MFRC522_PCD_Init</a> (void)</td></tr>
<tr class="memdesc:a88a7a1256442e386634da01b9b874998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise l'interface SPI.  <a href="#a88a7a1256442e386634da01b9b874998">Plus de détails...</a><br /></td></tr>
<tr class="separator:a88a7a1256442e386634da01b9b874998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee04653144111cf61127604d69c8d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9ee04653144111cf61127604d69c8d51">MFRC522_PCD_Reset</a> (void)</td></tr>
<tr class="memdesc:a9ee04653144111cf61127604d69c8d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Réinitialise le composant MFRC522.  <a href="#a9ee04653144111cf61127604d69c8d51">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9ee04653144111cf61127604d69c8d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015dec9a5519b8538b32baa99d28f077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a015dec9a5519b8538b32baa99d28f077">MFRC522_PCD_AntennaOn</a> (void)</td></tr>
<tr class="memdesc:a015dec9a5519b8538b32baa99d28f077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allume l'antenne.  <a href="#a015dec9a5519b8538b32baa99d28f077">Plus de détails...</a><br /></td></tr>
<tr class="separator:a015dec9a5519b8538b32baa99d28f077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38b1f22590608485bc6373c1224a601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ad38b1f22590608485bc6373c1224a601">MFRC522_PCD_AntennaOff</a> (void)</td></tr>
<tr class="memdesc:ad38b1f22590608485bc6373c1224a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eteint l'antenne.  <a href="#ad38b1f22590608485bc6373c1224a601">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad38b1f22590608485bc6373c1224a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac988302672b4d888730249ac218b52d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2">MFRC522_RX_GAIN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac988302672b4d888730249ac218b52d0">MFRC522_PCD_GetAntennaGain</a> (void)</td></tr>
<tr class="memdesc:ac988302672b4d888730249ac218b52d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient le gain de l'antenne.  <a href="#ac988302672b4d888730249ac218b52d0">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac988302672b4d888730249ac218b52d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ebd01d137d21794cbb3649189006ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a65ebd01d137d21794cbb3649189006ca">MFRC522_PCD_SetAntennaGain</a> (<a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2">MFRC522_RX_GAIN</a> gain)</td></tr>
<tr class="memdesc:a65ebd01d137d21794cbb3649189006ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Définit le gain de l'antenne.  <a href="#a65ebd01d137d21794cbb3649189006ca">Plus de détails...</a><br /></td></tr>
<tr class="separator:a65ebd01d137d21794cbb3649189006ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc59bf61d2bff44a84e0e89db78fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a38cc59bf61d2bff44a84e0e89db78fbb">MFRC522_PCD_PerformSelfTest</a> (void)</td></tr>
<tr class="memdesc:a38cc59bf61d2bff44a84e0e89db78fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test automatique du MFRC522.  <a href="#a38cc59bf61d2bff44a84e0e89db78fbb">Plus de détails...</a><br /></td></tr>
<tr class="separator:a38cc59bf61d2bff44a84e0e89db78fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd150891e3c490a177710205fa6f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#adcfd150891e3c490a177710205fa6f86">MFRC522_PCD_TransceiveData</a> (uint8_t *sendData, uint8_t sendLen, uint8_t *backData, uint8_t *backLen, uint8_t *validBits, uint8_t rxAlign, uint8_t checkCRC)</td></tr>
<tr class="memdesc:adcfd150891e3c490a177710205fa6f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exécute la commande de transfert dans la FIFO du MFRC522.  <a href="#adcfd150891e3c490a177710205fa6f86">Plus de détails...</a><br /></td></tr>
<tr class="separator:adcfd150891e3c490a177710205fa6f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b8c36b24ba229cc192a792caac62d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a41b8c36b24ba229cc192a792caac62d0">MFRC522_PICC_RequestA</a> (<a class="el" href="a00002.html">MFRC522_PICC_UID</a> *uid)</td></tr>
<tr class="memdesc:a41b8c36b24ba229cc192a792caac62d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Envoi une commande Request type A.  <a href="#a41b8c36b24ba229cc192a792caac62d0">Plus de détails...</a><br /></td></tr>
<tr class="separator:a41b8c36b24ba229cc192a792caac62d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7604f9c7275cd561647f60c6c8458b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab7604f9c7275cd561647f60c6c8458b4">MFRC522_PICC_WakeupA</a> (<a class="el" href="a00002.html">MFRC522_PICC_UID</a> *uid)</td></tr>
<tr class="memdesc:ab7604f9c7275cd561647f60c6c8458b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Envoi une commande Wakeup type A.  <a href="#ab7604f9c7275cd561647f60c6c8458b4">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab7604f9c7275cd561647f60c6c8458b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23dafc7582c3002cb52d0389a41c1ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac23dafc7582c3002cb52d0389a41c1ec">MFRC522_PICC_Select</a> (<a class="el" href="a00002.html">MFRC522_PICC_UID</a> *uid)</td></tr>
<tr class="memdesc:ac23dafc7582c3002cb52d0389a41c1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sélectionne un PICC.  <a href="#ac23dafc7582c3002cb52d0389a41c1ec">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac23dafc7582c3002cb52d0389a41c1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8f8cc6065c638e2644988be965777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a29f8f8cc6065c638e2644988be965777">MFRC522_PICC_HaltA</a> (void)</td></tr>
<tr class="memdesc:a29f8f8cc6065c638e2644988be965777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Envoi une commande Halt type A.  <a href="#a29f8f8cc6065c638e2644988be965777">Plus de détails...</a><br /></td></tr>
<tr class="separator:a29f8f8cc6065c638e2644988be965777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ba0ad4f22036448751f56d80a63b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aa1ba0ad4f22036448751f56d80a63b59">MFRC522_MIFARE_Authenticate</a> (<a class="el" href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4">MFRC522_AUTH_KEY</a> keytype, uint8_t blockAddr, <a class="el" href="a00001.html">MFRC522_MIFARE_KEY</a> *key, <a class="el" href="a00002.html">MFRC522_PICC_UID</a> *uid)</td></tr>
<tr class="memdesc:aa1ba0ad4f22036448751f56d80a63b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue l'authentification MIFARE sur un block spécifié  <a href="#aa1ba0ad4f22036448751f56d80a63b59">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa1ba0ad4f22036448751f56d80a63b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ec0080edccbd46e22e75d5745d2bb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac0ec0080edccbd46e22e75d5745d2bb7">MFRC522_MIFARE_StopCrypto1</a> (void)</td></tr>
<tr class="memdesc:ac0ec0080edccbd46e22e75d5745d2bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop l'utilisation de l'authentification MIFARE.  <a href="#ac0ec0080edccbd46e22e75d5745d2bb7">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac0ec0080edccbd46e22e75d5745d2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc38269694aaca1081f9327559411724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#afc38269694aaca1081f9327559411724">MFRC522_MIFARE_Read</a> (uint8_t blockAddr, uint8_t *buffer, uint8_t *bufferSize)</td></tr>
<tr class="memdesc:afc38269694aaca1081f9327559411724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit 16 octets (+2 CRC_A) du PICC ACTIF.  <a href="#afc38269694aaca1081f9327559411724">Plus de détails...</a><br /></td></tr>
<tr class="separator:afc38269694aaca1081f9327559411724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af652f395989dbce8064a5679115fa9cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af652f395989dbce8064a5679115fa9cf">MFRC522_MIFARE_Write</a> (uint8_t blockAddr, uint8_t *buffer, uint8_t bufferSize)</td></tr>
<tr class="memdesc:af652f395989dbce8064a5679115fa9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecrit 16 octets sur le PICC ACTIF.  <a href="#af652f395989dbce8064a5679115fa9cf">Plus de détails...</a><br /></td></tr>
<tr class="separator:af652f395989dbce8064a5679115fa9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad060eed5c2f314197b59d052572aab14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ad060eed5c2f314197b59d052572aab14">MFRC522_MIFARE_Decrement</a> (uint8_t blockAddr, int32_t delta)</td></tr>
<tr class="memdesc:ad060eed5c2f314197b59d052572aab14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soustrait le delta de la valeur stockée à l'adresse du bloc et stock le résultat dans la mémoire volatile.  <a href="#ad060eed5c2f314197b59d052572aab14">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad060eed5c2f314197b59d052572aab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b49dba203b00abdb4ad357b6ca525e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a69b49dba203b00abdb4ad357b6ca525e">MFRC522_MIFARE_Increment</a> (uint8_t blockAddr, int32_t delta)</td></tr>
<tr class="memdesc:a69b49dba203b00abdb4ad357b6ca525e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ajoute le delta de la valeur stockée à l'adresse du bloc et stock le résultat dans la mémoire volatile.  <a href="#a69b49dba203b00abdb4ad357b6ca525e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a69b49dba203b00abdb4ad357b6ca525e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ee075ea907230de403411986876ad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a11ee075ea907230de403411986876ad5">MFRC522_MIFARE_Restore</a> (uint8_t blockAddr)</td></tr>
<tr class="memdesc:a11ee075ea907230de403411986876ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place la valeur stockée à l'adresse d'un bloc dans la mémoire volatile.  <a href="#a11ee075ea907230de403411986876ad5">Plus de détails...</a><br /></td></tr>
<tr class="separator:a11ee075ea907230de403411986876ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5367c43aa316d6c7509af27a451b7e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a5367c43aa316d6c7509af27a451b7e8b">MFRC522_MIFARE_Transfer</a> (uint8_t blockAddr)</td></tr>
<tr class="memdesc:a5367c43aa316d6c7509af27a451b7e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecrit le contenu de la mémoire volatile dans un block.  <a href="#a5367c43aa316d6c7509af27a451b7e8b">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5367c43aa316d6c7509af27a451b7e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265b17588bdc955f9efb93719b52895b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a265b17588bdc955f9efb93719b52895b">MFRC522_MIFARE_Ultralight_Write</a> (uint8_t page, uint8_t *buffer, uint8_t bufferSize)</td></tr>
<tr class="memdesc:a265b17588bdc955f9efb93719b52895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecrit 4 octets dans une page du MIFARE Ultralight ACTIF.  <a href="#a265b17588bdc955f9efb93719b52895b">Plus de détails...</a><br /></td></tr>
<tr class="separator:a265b17588bdc955f9efb93719b52895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5263773974b6a152486da112de524f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#acd5263773974b6a152486da112de524f">MFRC522_MIFARE_Classic_GetValue</a> (uint8_t blockAddr, int32_t *value)</td></tr>
<tr class="memdesc:acd5263773974b6a152486da112de524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit la valeur d'un block d'un PICC MIFARE Classic.  <a href="#acd5263773974b6a152486da112de524f">Plus de détails...</a><br /></td></tr>
<tr class="separator:acd5263773974b6a152486da112de524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af697ac5719bd10495d99085f5e9dca45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af697ac5719bd10495d99085f5e9dca45">MFRC522_MIFARE_Classic_SetValue</a> (uint8_t blockAddr, int32_t value)</td></tr>
<tr class="memdesc:af697ac5719bd10495d99085f5e9dca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecrit la valeur d'un block d'un PICC MIFARE Classic.  <a href="#af697ac5719bd10495d99085f5e9dca45">Plus de détails...</a><br /></td></tr>
<tr class="separator:af697ac5719bd10495d99085f5e9dca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7ee2a68796dbf4d5f1d8433d41b083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6e">MFRC522_PICC_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aff7ee2a68796dbf4d5f1d8433d41b083">MFRC522_PICC_GetType</a> (<a class="el" href="a00002.html">MFRC522_PICC_UID</a> *uid)</td></tr>
<tr class="memdesc:aff7ee2a68796dbf4d5f1d8433d41b083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère le type de carte en fonction de son SAK.  <a href="#aff7ee2a68796dbf4d5f1d8433d41b083">Plus de détails...</a><br /></td></tr>
<tr class="separator:aff7ee2a68796dbf4d5f1d8433d41b083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d00e13ef93354b5b523f7267b47fdf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a7d00e13ef93354b5b523f7267b47fdf7">MFRC522_MIFARE_SetAccessBits</a> (uint8_t *accessBitBuffer, uint8_t g0, uint8_t g1, uint8_t g2, uint8_t g3)</td></tr>
<tr class="memdesc:a7d00e13ef93354b5b523f7267b47fdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul le bit pattern des bits d'accès.  <a href="#a7d00e13ef93354b5b523f7267b47fdf7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7d00e13ef93354b5b523f7267b47fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Bibliothèque de contrôle du lecteur MFRC522. </p>
<dl class="section author"><dt>Auteur</dt><dd>Zéro Cool </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15/06/2015 18:13:32</dd></dl>
<p>Bibliothèque d'utilisation du reader RFID MFRC522 en mode SPI.</p>
<dl class="section note"><dt>Note</dt><dd>PCD : Proximity Coupling Device (i.e. Lecteur NXP MFRC522 sans contactes) </dd>
<dd>
PICC : Proximity Integrated Circuit Card (i.e. Carte ou Tag utilisant l'interface ISO 14443A)</dd></dl>
<dl class="section user"><dt></dt><dd>Le lecteur de carte et le microcontroller communiquent en mode SPI.<br />
Le protocole est décrit dans la ([datasheet]<a href="http://www.nxp.com/documents/data_sheet/MFRC522.pdf">http://www.nxp.com/documents/data_sheet/MFRC522.pdf</a>)</dd></dl>
<dl class="section user"><dt></dt><dd>Le lecteur de carte et le tag communiquent par un champ électromagnétique de 13.56MHz.<br />
Le protocole d'identification s'appuie sur l'ISO/IEC 14443-3 : "Contactless integrated circuit cards -- Proximity cards -- Part 3: Initialization and anticollision".<br />
Une vesion gratuite du draft final est disponible ([ici]<a href="http://wg8.de/wg8n1496_17n3613_Ballot_FCD14443-3.pdf">http://wg8.de/wg8n1496_17n3613_Ballot_FCD14443-3.pdf</a>).<br />
Les détails se trouvent au chapitre 6, Type A – Initialization and anticollision.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>Si seulement l'UID du PICC est désiré, alors les documentations précédentes sont sufficantes.<br />
Pour lire ou écrire un PICC MIFARE, le bon protocol doit être sélectionné.</dd></dl>
<dl class="section user"><dt></dt><dd>Pour les tags "MIFARE Classic", les protocoles sont décrits ici :<br />
 <ul>
<li>1K : <a href="http://www.nxp.com/documents/data_sheet/MF1S503x.pdf">http://www.nxp.com/documents/data_sheet/MF1S503x.pdf</a> </li>
<li>4K : <a href="http://www.nxp.com/documents/data_sheet/MF1S703x.pdf">http://www.nxp.com/documents/data_sheet/MF1S703x.pdf</a> </li>
<li>Mini : <a href="http://www.idcardmarket.com/download/mifare_S20_datasheet.pdf">http://www.idcardmarket.com/download/mifare_S20_datasheet.pdf</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Pour les tags "MIFARE Ultralight", les protocoles sont décrits ici : <ul>
<li>Ultralight : <a href="http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf">http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf</a> </li>
<li>Ultralight C : <a href="http://www.nxp.com/documents/short_data_sheet/MF0ICU2_SDS.pdf">http://www.nxp.com/documents/short_data_sheet/MF0ICU2_SDS.pdf</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Résumé des caractéristiques des tags MIFARE : <ul>
<li>MIFARE Classic 1K (MF1S503x) :<br />
 Has 16 sectors * 4 blocks/sector * 16 bytes/block = 1024 bytes.<br />
 The blocks are numbered 0-63.<br />
 Block 3 in each sector is the Sector Trailer. See <a href="http://www.nxp.com/documents/data_sheet/MF1S503x.pdf">http://www.nxp.com/documents/data_sheet/MF1S503x.pdf</a> sections 8.6 and 8.7 :<br />
<ul>
<li>Bytes 0-5: Key A<br />
</li>
<li>Bytes 6-8: Access Bits<br />
</li>
<li>Bytes 9: User data<br />
</li>
<li>Bytes 10-15: Key B (or user data)<br />
 Block 0 is read-only manufacturer data.<br />
 To access a block, an authentication using a key from the block's sector must be performed first.<br />
 Example: To read from block 10, first authenticate using a key from sector 3 (blocks 8-11).<br />
 All keys are set to FFFFFFFFFFFFh at chip delivery.<br />
 Warning: Please read section 8.7 "Memory Access". It includes this text: if the PICC detects a format violation the whole sector is irreversibly blocked.<br />
 To use a block in "value block" mode (for Increment/Decrement operations) you need to change the sector trailer. Use PICC_SetAccessBits() to calculate the bit patterns.</li>
</ul>
</li>
</ul>
<ul>
<li>MIFARE Classic 4K (MF1S703x) :<br />
 Has (32 sectors * 4 blocks/sector + 8 sectors * 16 blocks/sector) * 16 bytes/block = 4096 bytes.<br />
 The blocks are numbered 0-255.<br />
 The last block in each sector is the Sector Trailer like above.</li>
</ul>
<ul>
<li>MIFARE Classic Mini (MF1 IC S20) :<br />
 Has 5 sectors * 4 blocks/sector * 16 bytes/block = 320 bytes.<br />
 The blocks are numbered 0-19.<br />
 The last block in each sector is the Sector Trailer like above.</li>
</ul>
<ul>
<li>MIFARE Ultralight (MF0ICU1) :<br />
 Has 16 pages of 4 bytes = 64 bytes.<br />
 Pages 0 + 1 is used for the 7-byte UID.<br />
 Page 2 contains the last check digit for the UID, one byte manufacturer internal data, and the lock bytes (see <a href="http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf">http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf</a> section 8.5.2)<br />
 Page 3 is OTP, One Time Programmable bits. Once set to 1 they cannot revert to 0.<br />
 Pages 4-15 are read/write unless blocked by the lock bytes in page 2.</li>
</ul>
<ul>
<li>MIFARE Ultralight C (MF0ICU2) :<br />
 Has 48 pages of 4 bytes = 192 bytes.<br />
 Pages 0 + 1 is used for the 7-byte UID.<br />
 Page 2 contains the last check digit for the UID, one byte manufacturer internal data, and the lock bytes (see <a href="http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf">http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf</a> section 8.5.2)<br />
 Page 3 is OTP, One Time Programmable bits. Once set to 1 they cannot revert to 0.<br />
 Pages 4-39 are read/write unless blocked by the lock bytes in page 2.<br />
 Page 40 Lock bytes<br />
 Page 41 16 bit one way counter<br />
 Pages 42-43 Authentication configuration<br />
 Pages 44-47 Authentication key</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Branchements préconisés : <hr/>
 MFRC522 Reader/PCD <h2>Signal Pin Variable </h2>
</dd></dl>
<p>RST/Reset RST MFRC522_RESET_PIN SPI SS NSS SPI_SS_PIN ou SDA(SS) SPI MOSI MOSI SPI_MOSI_PIN SPI MISO MISO SPI_MISO_PIN SPI SCK SCK SPI_SCK_PIN</p>
<dl class="section warning"><dt>Avertissement</dt><dd>La broche RST (ou Reset) doit se trouver sur le même port que la broche SPI_SS_PIN</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00018.html#_todo000007">A faire:</a></b></dt><dd>Exemple d'utilisation à faire</dd></dl>
</div><h2 class="groupheader">Documentation des macros</h2>
<a class="anchor" id="ae08583699989a52ba709c10416da4049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MFRC522_AUTH_KEY_SIZE&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Documentation du type de l'énumération</h2>
<a class="anchor" id="a89adaf1e8ac46b6d0c7bb83c58d152d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4">MFRC522_AUTH_KEY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types d'authentifications. </p>
<p>Enumération des types d'authentification possibles des blocs </p>
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a class="anchor" id="a89adaf1e8ac46b6d0c7bb83c58d152d4a1050aafc23ebab8d7c32a82fdfdaf954"></a>MFRC522_AUTH_KEY_A&#160;</td><td class="fielddoc">
<p>Clef d'authenfification A </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a89adaf1e8ac46b6d0c7bb83c58d152d4af338d6034d98313cb5f2b2ce58f8e8cd"></a>MFRC522_AUTH_KEY_B&#160;</td><td class="fielddoc">
<p>Clef d'authenfification A </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6e">MFRC522_PICC_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types de PICC ou de TAG. </p>
<p>Enumération des types de PICC. Cela permet d'en déduire les protocoles à utiliser par la suite. </p>
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea9c158029c33cf5f4af7e5500d4a1adc3"></a>MFRC522_PICC_TYPE_UNKNOWN&#160;</td><td class="fielddoc">
<p>Type de PICC inconnu </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea54181fb39067b717ec991e8b7cee9b8c"></a>MFRC522_PICC_TYPE_ISO_14443_4&#160;</td><td class="fielddoc">
<p>PICC compatible avec la norme ISO/IEC 14443-4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6eab17aa2fc84ed855b8f0739913068e5ad"></a>MFRC522_PICC_TYPE_ISO_18092&#160;</td><td class="fielddoc">
<p>PICC compatible avec la norme ISO/IEC 18092 (NFC) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea82440ae14051cfd6a163c44a368ceb37"></a>MFRC522_PICC_TYPE_MIFARE_MINI&#160;</td><td class="fielddoc">
<p>Protocole MIFARE Classic, 320 octets </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6eaa0842ffe78c7eb0e3e50023ab8555206"></a>MFRC522_PICC_TYPE_MIFARE_1K&#160;</td><td class="fielddoc">
<p>Protocole MIFARE Classic, 1 Ko </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea66d516f2f32de4afb43216b5ccf86804"></a>MFRC522_PICC_TYPE_MIFARE_4K&#160;</td><td class="fielddoc">
<p>Protocole MIFARE Classic, 4 Ko </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea5bdab066171aabf26e4a51a6b6f82abc"></a>MFRC522_PICC_TYPE_MIFARE_UL&#160;</td><td class="fielddoc">
<p>MIFARE Ultralight ou Ultralight C </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea7c1ca3a1d6007e3d8756683fbe9a2f29"></a>MFRC522_PICC_TYPE_MIFARE_PLUS&#160;</td><td class="fielddoc">
<p>MIFARE Plus </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea83f7ce6e4e57aacd2202e4f46cafb5d7"></a>MFRC522_PICC_TYPE_TNP3XXX&#160;</td><td class="fielddoc">
<p>Mentionné uniquement in NXP AN 10833 : MIFARE Type Identification Procedure </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea7e9a94106c447f4bf2961d0c5fe5557b"></a>MFRC522_PICC_TYPE_MIFARE_DESFIRE&#160;</td><td class="fielddoc">
<p>MMIFARE Desfire </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea6b65c8717db71b024d2a7a123b32a74f"></a>MFRC522_PICC_TYPE_JCOP30&#160;</td><td class="fielddoc">
<p>Protocole JEWEL </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6eaf9380812869951aa2e681c405eb0c754"></a>MFRC522_PICC_TYPE_MIFARE_4K_EMUL&#160;</td><td class="fielddoc">
<p>Emulation MIFARE 4K </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6ea9e0213161362742f92643edce79d1e0a"></a>MFRC522_PICC_TYPE_MIFARE_1K_INFINEON&#160;</td><td class="fielddoc">
<p>Infineon MIFARE 1K </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6eacda3341fc8f2e14b82d48fe3557e6859"></a>MFRC522_PICC_TYPE_MPCOS&#160;</td><td class="fielddoc">
<p>Protocole MPCOS </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1ab910a4592d91fed8ceb9c8f2014c6eada76c526ba87176f4f628d82dc4434cb"></a>MFRC522_PICC_TYPE_NOT_COMPLETE&#160;</td><td class="fielddoc">
<p>SAK indique que l'UID n'est pas complet </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8747255baf96533a382042038f5d01e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2">MFRC522_RX_GAIN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gain de l'antenne du MFRC522. </p>
<p>Enumération des gains possible pour l'antenne du MFRC522. Cf. 9.3.36 de la datasheet </p>
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2afcb05273c274750cba2cb1ae8ec31d46"></a>MFRC522_RX_GAIN_18dB&#160;</td><td class="fielddoc">
<p>000b - 18 dB, minimum </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a9ab1cf9c2403c2949445703731c3cf00"></a>MFRC522_RX_GAIN_23dB&#160;</td><td class="fielddoc">
<p>001b - 23 dB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a74acf107731fe1219418952ce2305d0b"></a>MFRC522_RX_GAIN_18dB_2&#160;</td><td class="fielddoc">
<p>010b - 18 dB, it seems 010b is a duplicate for 000b </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2abad30223c4834bf710e92114c744e4b4"></a>MFRC522_RX_GAIN_23dB_2&#160;</td><td class="fielddoc">
<p>011b - 23 dB, it seems 011b is a duplicate for 001b </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2aa6fcbb3cd63e11fca940078f9e8dbf4e"></a>MFRC522_RX_GAIN_33dB&#160;</td><td class="fielddoc">
<p>100b - 33 dB, average, and typical default </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a8a38c126caee6ca9fb7e367c1bc71e56"></a>MFRC522_RX_GAIN_38dB&#160;</td><td class="fielddoc">
<p>101b - 38 dB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a084739aeeced2f9026282737599ccdc6"></a>MFRC522_RX_GAIN_43dB&#160;</td><td class="fielddoc">
<p>110b - 43 dB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a63303a08e7efc9260a3941c66724204e"></a>MFRC522_RX_GAIN_48dB&#160;</td><td class="fielddoc">
<p>111b - 48 dB, maximum </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a5f11b0cec323f27214e932956a947b10"></a>MFRC522_RX_GAIN_min&#160;</td><td class="fielddoc">
<p>000b - 18 dB, minimum, convenience for RxGain_18dB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2aa7596c72c96bc7fa61de6656348bddf1"></a>MFRC522_RX_GAIN_avg&#160;</td><td class="fielddoc">
<p>100b - 33 dB, average, convenience for RxGain_33dB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8747255baf96533a382042038f5d01e2a47711a5991c0a3c7d8519bfbb5f4fc9e"></a>MFRC522_RX_GAIN_max&#160;</td><td class="fielddoc">
<p>111b - 48 dB, maximum, convenience for RxGain_48dB </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Codes retour des fonctions de la bibliothèque. </p>
<p>Enumération des codes retous possibles de la bibliothèque MFRC522 </p>
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7aed60c850eb757e8c9bb408da0b9f2460"></a>MFRC522_STATUS_OK&#160;</td><td class="fielddoc">
<p>Success </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7afb2bf8b2b3b762f8881f4b50becffbe7"></a>MFRC522_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>Erreur de communication </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a66c6e7b431d9c23df53dde3b31c44ab5"></a>MFRC522_STATUS_COLLISION&#160;</td><td class="fielddoc">
<p>Collision détectée </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a75dc0fdffad4fc369637e38d39378386"></a>MFRC522_STATUS_TIMEOUT&#160;</td><td class="fielddoc">
<p>Timeout </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7afd52fd20b34b011fbec8d5062a0f87e1"></a>MFRC522_STATUS_NO_ROOM&#160;</td><td class="fielddoc">
<p>Un buffer n'est pas assez grand </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a9cfb9908f0583d4cfb7b789511c61e67"></a>MFRC522_STATUS_INTERNAL_ERROR&#160;</td><td class="fielddoc">
<p>Erreur interne </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a3bf363bbf4ddb7134662d1ad48c7934f"></a>MFRC522_STATUS_INVALID&#160;</td><td class="fielddoc">
<p>Argument non valide </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a1614845f5f84e683c97e84aed6dfd255"></a>MFRC522_STATUS_CRC_WRONG&#160;</td><td class="fielddoc">
<p>Le CRC_A ne correspond pas </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a627fb17aba855e860a82e8b7300f7e94"></a>MFRC522_STATUS_MIFARE_NACK&#160;</td><td class="fielddoc">
<p>Une carte MIFARE a répondu par NAK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a34fca9ae70a2078ae9aa791acb68f5b6"></a>MFRC522_STATUS_PROPRIETARY_ANTICOLLISION&#160;</td><td class="fielddoc">
<p>Mode anticllision propriétaire </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ed729867f3e31ba760da8cdf874c9d7a8b7b2abc49823383fc4ac7cf89709007"></a>MFRC522_STATUS_BCC_ERROR&#160;</td><td class="fielddoc">
<p>Erreur de contrôle de la valeur du BCC </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions</h2>
<a class="anchor" id="aa1ba0ad4f22036448751f56d80a63b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Authenticate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html#a89adaf1e8ac46b6d0c7bb83c58d152d4">MFRC522_AUTH_KEY</a>&#160;</td>
          <td class="paramname"><em>keytype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html">MFRC522_MIFARE_KEY</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">MFRC522_PICC_UID</a> *&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue l'authentification MIFARE sur un block spécifié </p>
<p>Effectue une authentification MIFARE pour sécuriser les accès MIFARE Mini, MIFARE 1K et MIFARE 4K.<br />
 L'authentification est décrite dans le paragraphe 10.3.1.9 de la datasheet et dans la section 10.1 de la datasheet <a href="http://www.nxp.com/documents/data_sheet/MF1S503x.pdf">http://www.nxp.com/documents/data_sheet/MF1S503x.pdf</a> pour l'utilisation avec une carte MIFARE Classic PICCs.</p>
<dl class="section note"><dt>Note</dt><dd>Le PICC doit être sélectionné avant d'utiliser cette focntion. </dd>
<dd>
Il convient d'appeler MFRC522_MIFARE_StopScrypto1() après une communication authentifiée avec le PICC (Sinon plus aucune communication n'est possible). </dd>
<dd>
Toutes les clefs sont positionnées à 0xFFFFFFFFFFFF en sortie d'usine.</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keytype</td><td>Type de clef à utiliser pour l'authentification </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Adresse du bloc sur lequel s'authentifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Clef à utiliser pour l'authentification </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>Carte sur laquelle effectuer l'authentification</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur (Timeout si la clef fournie n'est pas correcte). </dd></dl>

</div>
</div>
<a class="anchor" id="acd5263773974b6a152486da112de524f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Classic_GetValue </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lit la valeur d'un block d'un PICC MIFARE Classic. </p>
<p>Permet de lire facilement la valeur stockée dans un bloc.</p>
<dl class="section note"><dt>Note</dt><dd>Le secteur contenant le block doit être authentifié avant d'appeler cette fonction.<br />
 Cette restriction n'est que pour les blocks en mode "valide" (bits d'accès [C1 C2 C3] = [110] ou [001]).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Addresse du block à utiliser (0x00 -&gt; 0xFF) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Valeur lue dans le block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="af697ac5719bd10495d99085f5e9dca45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Classic_SetValue </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ecrit la valeur d'un block d'un PICC MIFARE Classic. </p>
<p>Permet d'écrire facilement la valeur dans un bloc.</p>
<dl class="section note"><dt>Note</dt><dd>Le secteur contenant le block doit être authentifié avant d'appeler cette fonction.<br />
 Cette restriction n'est que pour les blocks en mode "valide" (bits d'accès [C1 C2 C3] = [110] ou [001]).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Addresse du block à utiliser (0x00 -&gt; 0xFF) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Nouvelle valeur à stocker dans le block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="ad060eed5c2f314197b59d052572aab14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Decrement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Soustrait le delta de la valeur stockée à l'adresse du bloc et stock le résultat dans la mémoire volatile. </p>
<p>MIFARE Decrement soustrait le delta passé en paramètre de la valeur présente à l'adresse fournie en entrée. Le résultat est stocké dans la mémoire volatile. Utiliser la fonction <code><a class="el" href="a00010.html#a5367c43aa316d6c7509af27a451b7e8b" title="Ecrit le contenu de la mémoire volatile dans un block. ">MFRC522_MIFARE_Transfer()</a></code> pour stoker le résultat de la mémoire volatile dans un block particulier.</p>
<dl class="section note"><dt>Note</dt><dd>Pour les PICC MIFARE Classic, le secteur contenant le block doit être authentifié avant d'appeler cette fonction.<br />
 Cette restriction n'est que pour les blocks en mode "valide" (bits d'accès [C1 C2 C3] = [110] ou [001]).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Addresse du block à soustraire </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>Valeur à soustraire</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a69b49dba203b00abdb4ad357b6ca525e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Increment </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ajoute le delta de la valeur stockée à l'adresse du bloc et stock le résultat dans la mémoire volatile. </p>
<p>MIFARE Increment ajoute le delta passé en paramètre de la valeur présente à l'adresse fournie en entrée. Le résultat est stocké dans la mémoire volatile. Utiliser la fonction <code><a class="el" href="a00010.html#a5367c43aa316d6c7509af27a451b7e8b" title="Ecrit le contenu de la mémoire volatile dans un block. ">MFRC522_MIFARE_Transfer()</a></code> pour stoker le résultat de la mémoire volatile dans un block particulier.</p>
<dl class="section note"><dt>Note</dt><dd>Pour les PICC MIFARE Classic, le secteur contenant le block doit être authentifié avant d'appeler cette fonction.<br />
 Cette restriction n'est que pour les blocks en mode "valide" (bits d'accès [C1 C2 C3] = [110] ou [001]).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Addresse du block à incrémenter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>Valeur à incrémenter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="afc38269694aaca1081f9327559411724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lit 16 octets (+2 CRC_A) du PICC ACTIF. </p>
<p>Lit 16 octets (+2 CRC_A) du PICC ACTIF. La focntion vérifie le CRC_A avant de retourner <code>MFRC511_STATUS_OK</code> </p>
<dl class="section note"><dt>Note</dt><dd>Pour les cartes MIFARE Classic, le secteur contenant le bloc à lire doit avoir été authentifié avant d'utiliser cette fonction.</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Adresse du bloc à lire </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer où seront stocké les données lues </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufferSize</td><td>Taille du buffer (doit être au moins de 18 octets). Le CRC_A est également retourné</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a11ee075ea907230de403411986876ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Restore </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place la valeur stockée à l'adresse d'un bloc dans la mémoire volatile. </p>
<p>MIFARE Restore place la valeur présente à l'adresse d'un block fournie en entrée dans la mémoire volatile. Utiliser la fonction <code><a class="el" href="a00010.html#a5367c43aa316d6c7509af27a451b7e8b" title="Ecrit le contenu de la mémoire volatile dans un block. ">MFRC522_MIFARE_Transfer()</a></code> pour stoker le résultat de la mémoire volatile dans un block particulier.</p>
<dl class="section note"><dt>Note</dt><dd>Pour les PICC MIFARE Classic, le secteur contenant le block doit être authentifié avant d'appeler cette fonction.<br />
 Cette restriction n'est que pour les blocks en mode "valide" (bits d'accès [C1 C2 C3] = [110] ou [001]).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Addresse du block à utiliser</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d00e13ef93354b5b523f7267b47fdf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_MIFARE_SetAccessBits </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>accessBitBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcul le bit pattern des bits d'accès. </p>
<p>Calcul le bit pattern des bits d'accès</p>
<dl class="section note"><dt>Note</dt><dd>In the [C1 C2 C3] tupples C1 is MSB (=4) and C3 is LSB (=1).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">accessBitBuffer</td><td>Buffer des bits d'accès à mettre à jour (pointeur vers les octets 6, 7 et 8 du sector trailer) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g0</td><td>bits d'accès [C1 C2 C3] du block 0 (secteurs 0-31) ou block 0-4 (secteurs 32-39) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1</td><td>bits d'accès [C1 C2 C3] du block 1 (secteurs 0-31) ou block 5-9 (secteurs 32-39) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2</td><td>bits d'accès [C1 C2 C3] du block 2 (secteurs 0-31) ou block 10-14 (secteurs 32-39) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3</td><td>bits d'accès [C1 C2 C3] du sector trailer, block 3 (secteurs 0-31) ou block 15 (secteurs 32-39) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0ec0080edccbd46e22e75d5745d2bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_MIFARE_StopCrypto1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop l'utilisation de l'authentification MIFARE. </p>
<p>Stop l'utilisation de l'authentification MIFARE </p>

</div>
</div>
<a class="anchor" id="a5367c43aa316d6c7509af27a451b7e8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Transfer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ecrit le contenu de la mémoire volatile dans un block. </p>
<p>MIFARE Transfert place le contenu de la mémoire volatile dans le block à l'adresse fournie en entrée.</p>
<dl class="section note"><dt>Note</dt><dd>Pour les PICC MIFARE Classic, le secteur contenant le block doit être authentifié avant d'appeler cette fonction.<br />
 Cette restriction n'est que pour les blocks en mode "valide" (bits d'accès [C1 C2 C3] = [110] ou [001]).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Addresse du block à utiliser</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a265b17588bdc955f9efb93719b52895b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Ultralight_Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ecrit 4 octets dans une page du MIFARE Ultralight ACTIF. </p>
<p>Permet d'écrire 4 octets dans une page données pour un PICC MIFARE Ultralight.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page où stocker les données </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer de 4 octets à écrire dans la page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Taille du buffer (Doit être supérieur à 4). Seul les 4 premiers octets du buffer sont utilisés.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est fait.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="af652f395989dbce8064a5679115fa9cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_MIFARE_Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ecrit 16 octets sur le PICC ACTIF. </p>
<p>Ecrit 16 octets sur le PICC ACTIF</p>
<dl class="section note"><dt>Note</dt><dd>Pour les cartes MIFARE Classic, le secteur contenant le bloc à écrire doit avoir été authentifié avant d'utiliser cette fonction. </dd>
<dd>
Pour les cartes MIFARE Ultralight, cette opération est nommée "COMPATIBILITY WRITE". Même Si 16 octets sont transmis au PICC, seuls les 4 premiers octets sont réellement écrit à l'adresse spécifiée. Il est recommandé de placer tous les octets suivant à la valeur 0x00.</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blockAddr</td><td>Adresse du bloc à écrire </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer des 16 octets à écrire </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Taille du buffer (doit être au moins de 16 octets - Seul les 16 premiers octets sont envoyés au PICC)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="ad38b1f22590608485bc6373c1224a601"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_PCD_AntennaOff </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eteint l'antenne. </p>
<p>Eteint l'antenne du composant MFRC522 </p>

</div>
</div>
<a class="anchor" id="a015dec9a5519b8538b32baa99d28f077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_PCD_AntennaOn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allume l'antenne. </p>
<p>Met en marche l'antenne du composant MFRC522 </p>

</div>
</div>
<a class="anchor" id="ac988302672b4d888730249ac218b52d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2">MFRC522_RX_GAIN</a> MFRC522_PCD_GetAntennaGain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtient le gain de l'antenne. </p>
<p>Récupère le gain de l'antenne du composant MFRC522</p>
<dl class="section return"><dt>Renvoie</dt><dd>Valeur du gain de l'antenne </dd></dl>

</div>
</div>
<a class="anchor" id="a88a7a1256442e386634da01b9b874998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_PCD_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise l'interface SPI. </p>
<dl class="section note"><dt>Note</dt><dd>Cette méthode n'est à appeler qu'une seule fois </dd></dl>

</div>
</div>
<a class="anchor" id="a38cc59bf61d2bff44a84e0e89db78fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_PCD_PerformSelfTest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test automatique du MFRC522. </p>
<p>Effectue un test du firmware du MFRC522</p>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_ERROR en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee04653144111cf61127604d69c8d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_PCD_Reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Réinitialise le composant MFRC522. </p>
<p>Effectue une réinitialisation software du composant MFRC522 </p>

</div>
</div>
<a class="anchor" id="a65ebd01d137d21794cbb3649189006ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFRC522_PCD_SetAntennaGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html#a8747255baf96533a382042038f5d01e2">MFRC522_RX_GAIN</a>&#160;</td>
          <td class="paramname"><em>gain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Définit le gain de l'antenne. </p>
<p>Définit le gain de l'antenne du composant MFRC522 </p>

</div>
</div>
<a class="anchor" id="adcfd150891e3c490a177710205fa6f86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_PCD_TransceiveData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sendLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>backData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>backLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>validBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxAlign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>checkCRC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exécute la commande de transfert dans la FIFO du MFRC522. </p>
<p>Exécute la commande PCD_CMD_Transceive qui envoi les données de la FIFO vers l'antenne</p>
<dl class="section note"><dt>Note</dt><dd>La validation CRC ne peut être faite que si <code>backData</code> et <code>backLen</code> sont spécifiés</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Pointeur des données à transférer dans la FIFO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendLen</td><td>Nombre d'octets à transférer dans la FIFO </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backData</td><td>NULL ou pointeur vers le buffer devant récupérer les données après transfert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backLen</td><td>Valeurs possibles : <ul>
<li><code>in</code> : Nombre max d'octets pouvant être écrit dans le buffer backData </li>
<li><code>out</code> : Nombre d'octets retournés </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">validBits</td><td>Nombre de bits valids pour le dernier octets (0 à 8). NULL par défaut </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxAlign</td><td>Définit la position du bit dans backData[0] pour le premier bit reçu. Par défaut 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkCRC</td><td>Valeurs possible : <ul>
<li><code>0</code> -&gt; Pas de contrôle CRC. </li>
<li><code>1</code> -&gt; Les deux derniers octets sont considérés comme CRC_A et sont donc validés.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="aff7ee2a68796dbf4d5f1d8433d41b083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a1ab910a4592d91fed8ceb9c8f2014c6e">MFRC522_PICC_TYPE</a> MFRC522_PICC_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">MFRC522_PICC_UID</a> *&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Récupère le type de carte en fonction de son SAK. </p>
<p>Permet d'identifier le type de carte.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>Structure UID de la carte à analyser</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Le type de carte déterminé. </dd></dl>

</div>
</div>
<a class="anchor" id="a29f8f8cc6065c638e2644988be965777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_PICC_HaltA </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Envoi une commande Halt type A. </p>
<p>Invite le PICC de passer de l'état ACTIVE à l'état HALT. </p><dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a41b8c36b24ba229cc192a792caac62d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_PICC_RequestA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">MFRC522_PICC_UID</a> *&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Envoi une commande Request type A. </p>
<p>Invite le PICC de passer de l'état IDLE à l'état READY et se prépare pour l'anticollision ou la sélection.<br />
 Frame de 7 bits.<br />
 </p><dl class="section warning"><dt>Avertissement</dt><dd>Quand deux PICC sont dans le champ au même moment, un MFRC522_STATUS_TIMEOUT sera probablement déclenché.</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uid</td><td>Pointeur sur une structure de type <a class="el" href="a00002.html" title="Structure contenant l&#39;UID d&#39;un PICC. ">MFRC522_PICC_UID</a>.<br />
 La zone ATQA est alimentée en sortie</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="ac23dafc7582c3002cb52d0389a41c1ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_PICC_Select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">MFRC522_PICC_UID</a> *&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sélectionne un PICC. </p>
<p>Envoi une command SELECT/ANTICOLLISION à un seul PICC.</p>
<dl class="section warning"><dt>Avertissement</dt><dd>Avant d'utiliser cette fonction, le PICC doit être placé dans un état READY (</dd></dl>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="a00010.html#a41b8c36b24ba229cc192a792caac62d0" title="Envoi une commande Request type A. ">MFRC522_PICC_RequestA</a> ou </dd>
<dd>
<a class="el" href="a00010.html#ab7604f9c7275cd561647f60c6c8458b4" title="Envoi une commande Wakeup type A. ">MFRC522_PICC_WakeupA</a>) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>En cas de succès : <ul>
<li>Le PICC choisi passe à l'état ACTIVE et tous les autres PICC retourne à l'état IDLE/HALT (Figure 7 of the ISO/IEC 14443-3 draft.) </li>
<li>La taille du UID et la valeur du PICC choisie est retourné dans la structure <code>*uid</code> avec le code SAK retour.</li>
</ul>
</dd>
<dd>
L'UID d'un PICC est constitué de 4, 7 ou 10 octets :<br />
 Seul 4 octets sont spécifiés dans la commande SELECT, donc, pour les UID de 7 et 10 octets, il faut respectivement 2 et 3 itérations (cascade level).</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uid</td><td>Pointeur sur une structure de type <a class="el" href="a00002.html" title="Structure contenant l&#39;UID d&#39;un PICC. ">MFRC522_PICC_UID</a>.<br />
 Permet de spécifier en entrée un UID connu.<br />
 Alimenté en sortie avec l'UID du PICC sélectionné.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00018.html#_todo000008">A faire:</a></b></dt><dd>Gérer la sélection d'un PICC déjà connu (en entrée de la fonction Select) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00018.html#_todo000009">A faire:</a></b></dt><dd>Gérer les collisions </dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00018.html#_todo000010">A faire:</a></b></dt><dd>Faire les autres cascade levels </dd></dl>

</div>
</div>
<a class="anchor" id="ab7604f9c7275cd561647f60c6c8458b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a8ed729867f3e31ba760da8cdf874c9d7">MFRC522_STATUS</a> MFRC522_PICC_WakeupA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">MFRC522_PICC_UID</a> *&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Envoi une commande Wakeup type A. </p>
<p>Invite le PICC de passer de l'état IDLE et HALT à l'état READY et se prépare pour l'anticollision ou la sélection.<br />
 Frame de 7 bits.<br />
 </p><dl class="section warning"><dt>Avertissement</dt><dd>Quand deux PICC sont dans le champ au même moment, un MFRC522_STATUS_TIMEOUT sera probablement déclenché.</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uid</td><td>Pointeur sur une structure de type <a class="el" href="a00002.html" title="Structure contenant l&#39;UID d&#39;un PICC. ">MFRC522_PICC_UID</a>.<br />
 La zone ATQA est alimentée en sortie</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Aucun dépassement de capacité n'est testé.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>MFRC522_STATUS_OK si le test est OK. MFRC522_STATUS_* en cas d'erreur. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_05b7b4f536b9e3a4aecd1837151d279c.html">include</a></li><li class="navelem"><a class="el" href="dir_07b2f03de813145a75523f1d5a4d5370.html">RFID</a></li><li class="navelem"><a class="el" href="a00010.html">MFRC522.h</a></li>
    <li class="footer">Généré le Samedi 31 Octobre 2015 00:46:37 pour avr.sdk par
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
